#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  WorkflowService API is exposed to provide support for long running applications.  Application is expected to call
  StartWorkflowExecution to create an instance for each instance of long running workflow.  Such applications are expected
  to have a worker which regularly polls for DecisionTask and ActivityTask from the WorkflowService.  For each
  DecisionTask, application is expected to process the history of events for that session and respond back with next
  decisions.  For each ActivityTask, application is expected to execute the actual logic for that task and respond back
  with completion or failure.  Worker is expected to regularly heartbeat while activity task is running.

  """
  def StartWorkflowExecution(self, startRequest):
    """
    StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
    'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
    first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
    exists with same workflowId.


    Parameters:
     - startRequest
    """
    pass

  def GetWorkflowExecutionHistory(self, getRequest):
    """
    Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if speficied workflow
    execution in unknown to the service.


    Parameters:
     - getRequest
    """
    pass

  def PollForDecisionTask(self, pollRequest):
    """
    PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.  A
    DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
    Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
    It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
    application worker.


    Parameters:
     - pollRequest
    """
    pass

  def RespondDecisionTaskCompleted(self, completeRequest):
    """
    RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
    'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
    potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
    event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
    for completing the DecisionTask.


    Parameters:
     - completeRequest
    """
    pass

  def PollForActivityTask(self, pollRequest):
    """
    PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
    is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
    Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
    processing the task.
    Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
    prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
    history before the ActivityTask is dispatched to application worker.


    Parameters:
     - pollRequest
    """
    pass

  def RecordActivityTaskHeartbeat(self, heartbeatRequest):
    """
    RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
    to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
    'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
    fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for heartbeating.


    Parameters:
     - heartbeatRequest
    """
    pass

  def RespondActivityTaskCompleted(self, completeRequest):
    """
    RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
    created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - completeRequest
    """
    pass

  def RespondActivityTaskFailed(self, failRequest):
    """
    RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - failRequest
    """
    pass

  def RespondActivityTaskCanceled(self, canceledRequest):
    """
    RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
    result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - canceledRequest
    """
    pass


class Client(Iface):
  """
  WorkflowService API is exposed to provide support for long running applications.  Application is expected to call
  StartWorkflowExecution to create an instance for each instance of long running workflow.  Such applications are expected
  to have a worker which regularly polls for DecisionTask and ActivityTask from the WorkflowService.  For each
  DecisionTask, application is expected to process the history of events for that session and respond back with next
  decisions.  For each ActivityTask, application is expected to execute the actual logic for that task and respond back
  with completion or failure.  Worker is expected to regularly heartbeat while activity task is running.

  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def StartWorkflowExecution(self, startRequest):
    """
    StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
    'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
    first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
    exists with same workflowId.


    Parameters:
     - startRequest
    """
    self.send_StartWorkflowExecution(startRequest)
    return self.recv_StartWorkflowExecution()

  def send_StartWorkflowExecution(self, startRequest):
    self._oprot.writeMessageBegin('StartWorkflowExecution', TMessageType.CALL, self._seqid)
    args = StartWorkflowExecution_args()
    args.startRequest = startRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_StartWorkflowExecution(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = StartWorkflowExecution_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.sessionAlreadyExistError is not None:
      raise result.sessionAlreadyExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "StartWorkflowExecution failed: unknown result");

  def GetWorkflowExecutionHistory(self, getRequest):
    """
    Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if speficied workflow
    execution in unknown to the service.


    Parameters:
     - getRequest
    """
    self.send_GetWorkflowExecutionHistory(getRequest)
    return self.recv_GetWorkflowExecutionHistory()

  def send_GetWorkflowExecutionHistory(self, getRequest):
    self._oprot.writeMessageBegin('GetWorkflowExecutionHistory', TMessageType.CALL, self._seqid)
    args = GetWorkflowExecutionHistory_args()
    args.getRequest = getRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetWorkflowExecutionHistory(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetWorkflowExecutionHistory_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetWorkflowExecutionHistory failed: unknown result");

  def PollForDecisionTask(self, pollRequest):
    """
    PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.  A
    DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
    Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
    It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
    application worker.


    Parameters:
     - pollRequest
    """
    self.send_PollForDecisionTask(pollRequest)
    return self.recv_PollForDecisionTask()

  def send_PollForDecisionTask(self, pollRequest):
    self._oprot.writeMessageBegin('PollForDecisionTask', TMessageType.CALL, self._seqid)
    args = PollForDecisionTask_args()
    args.pollRequest = pollRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_PollForDecisionTask(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = PollForDecisionTask_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "PollForDecisionTask failed: unknown result");

  def RespondDecisionTaskCompleted(self, completeRequest):
    """
    RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
    'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
    potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
    event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
    for completing the DecisionTask.


    Parameters:
     - completeRequest
    """
    self.send_RespondDecisionTaskCompleted(completeRequest)
    self.recv_RespondDecisionTaskCompleted()

  def send_RespondDecisionTaskCompleted(self, completeRequest):
    self._oprot.writeMessageBegin('RespondDecisionTaskCompleted', TMessageType.CALL, self._seqid)
    args = RespondDecisionTaskCompleted_args()
    args.completeRequest = completeRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondDecisionTaskCompleted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondDecisionTaskCompleted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    return

  def PollForActivityTask(self, pollRequest):
    """
    PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
    is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
    Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
    processing the task.
    Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
    prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
    history before the ActivityTask is dispatched to application worker.


    Parameters:
     - pollRequest
    """
    self.send_PollForActivityTask(pollRequest)
    return self.recv_PollForActivityTask()

  def send_PollForActivityTask(self, pollRequest):
    self._oprot.writeMessageBegin('PollForActivityTask', TMessageType.CALL, self._seqid)
    args = PollForActivityTask_args()
    args.pollRequest = pollRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_PollForActivityTask(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = PollForActivityTask_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "PollForActivityTask failed: unknown result");

  def RecordActivityTaskHeartbeat(self, heartbeatRequest):
    """
    RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
    to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
    'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
    fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for heartbeating.


    Parameters:
     - heartbeatRequest
    """
    self.send_RecordActivityTaskHeartbeat(heartbeatRequest)
    return self.recv_RecordActivityTaskHeartbeat()

  def send_RecordActivityTaskHeartbeat(self, heartbeatRequest):
    self._oprot.writeMessageBegin('RecordActivityTaskHeartbeat', TMessageType.CALL, self._seqid)
    args = RecordActivityTaskHeartbeat_args()
    args.heartbeatRequest = heartbeatRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RecordActivityTaskHeartbeat(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RecordActivityTaskHeartbeat_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    raise TApplicationException(TApplicationException.MISSING_RESULT, "RecordActivityTaskHeartbeat failed: unknown result");

  def RespondActivityTaskCompleted(self, completeRequest):
    """
    RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
    created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - completeRequest
    """
    self.send_RespondActivityTaskCompleted(completeRequest)
    self.recv_RespondActivityTaskCompleted()

  def send_RespondActivityTaskCompleted(self, completeRequest):
    self._oprot.writeMessageBegin('RespondActivityTaskCompleted', TMessageType.CALL, self._seqid)
    args = RespondActivityTaskCompleted_args()
    args.completeRequest = completeRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondActivityTaskCompleted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondActivityTaskCompleted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return

  def RespondActivityTaskFailed(self, failRequest):
    """
    RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
    result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - failRequest
    """
    self.send_RespondActivityTaskFailed(failRequest)
    self.recv_RespondActivityTaskFailed()

  def send_RespondActivityTaskFailed(self, failRequest):
    self._oprot.writeMessageBegin('RespondActivityTaskFailed', TMessageType.CALL, self._seqid)
    args = RespondActivityTaskFailed_args()
    args.failRequest = failRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondActivityTaskFailed(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondActivityTaskFailed_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return

  def RespondActivityTaskCanceled(self, canceledRequest):
    """
    RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
    result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
    created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
    PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
    anymore due to activity timeout.


    Parameters:
     - canceledRequest
    """
    self.send_RespondActivityTaskCanceled(canceledRequest)
    self.recv_RespondActivityTaskCanceled()

  def send_RespondActivityTaskCanceled(self, canceledRequest):
    self._oprot.writeMessageBegin('RespondActivityTaskCanceled', TMessageType.CALL, self._seqid)
    args = RespondActivityTaskCanceled_args()
    args.canceledRequest = canceledRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RespondActivityTaskCanceled(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = RespondActivityTaskCanceled_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.badRequestError is not None:
      raise result.badRequestError
    if result.internalServiceError is not None:
      raise result.internalServiceError
    if result.entityNotExistError is not None:
      raise result.entityNotExistError
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["StartWorkflowExecution"] = Processor.process_StartWorkflowExecution
    self._processMap["GetWorkflowExecutionHistory"] = Processor.process_GetWorkflowExecutionHistory
    self._processMap["PollForDecisionTask"] = Processor.process_PollForDecisionTask
    self._processMap["RespondDecisionTaskCompleted"] = Processor.process_RespondDecisionTaskCompleted
    self._processMap["PollForActivityTask"] = Processor.process_PollForActivityTask
    self._processMap["RecordActivityTaskHeartbeat"] = Processor.process_RecordActivityTaskHeartbeat
    self._processMap["RespondActivityTaskCompleted"] = Processor.process_RespondActivityTaskCompleted
    self._processMap["RespondActivityTaskFailed"] = Processor.process_RespondActivityTaskFailed
    self._processMap["RespondActivityTaskCanceled"] = Processor.process_RespondActivityTaskCanceled

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_StartWorkflowExecution(self, seqid, iprot, oprot):
    args = StartWorkflowExecution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = StartWorkflowExecution_result()
    try:
      result.success = self._handler.StartWorkflowExecution(args.startRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.WorkflowExecutionAlreadyStartedError, sessionAlreadyExistError:
      result.sessionAlreadyExistError = sessionAlreadyExistError
    oprot.writeMessageBegin("StartWorkflowExecution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetWorkflowExecutionHistory(self, seqid, iprot, oprot):
    args = GetWorkflowExecutionHistory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetWorkflowExecutionHistory_result()
    try:
      result.success = self._handler.GetWorkflowExecutionHistory(args.getRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("GetWorkflowExecutionHistory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PollForDecisionTask(self, seqid, iprot, oprot):
    args = PollForDecisionTask_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PollForDecisionTask_result()
    try:
      result.success = self._handler.PollForDecisionTask(args.pollRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    oprot.writeMessageBegin("PollForDecisionTask", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondDecisionTaskCompleted(self, seqid, iprot, oprot):
    args = RespondDecisionTaskCompleted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondDecisionTaskCompleted_result()
    try:
      self._handler.RespondDecisionTaskCompleted(args.completeRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    oprot.writeMessageBegin("RespondDecisionTaskCompleted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_PollForActivityTask(self, seqid, iprot, oprot):
    args = PollForActivityTask_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = PollForActivityTask_result()
    try:
      result.success = self._handler.PollForActivityTask(args.pollRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    oprot.writeMessageBegin("PollForActivityTask", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RecordActivityTaskHeartbeat(self, seqid, iprot, oprot):
    args = RecordActivityTaskHeartbeat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RecordActivityTaskHeartbeat_result()
    try:
      result.success = self._handler.RecordActivityTaskHeartbeat(args.heartbeatRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RecordActivityTaskHeartbeat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondActivityTaskCompleted(self, seqid, iprot, oprot):
    args = RespondActivityTaskCompleted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondActivityTaskCompleted_result()
    try:
      self._handler.RespondActivityTaskCompleted(args.completeRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondActivityTaskCompleted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondActivityTaskFailed(self, seqid, iprot, oprot):
    args = RespondActivityTaskFailed_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondActivityTaskFailed_result()
    try:
      self._handler.RespondActivityTaskFailed(args.failRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondActivityTaskFailed", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RespondActivityTaskCanceled(self, seqid, iprot, oprot):
    args = RespondActivityTaskCanceled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RespondActivityTaskCanceled_result()
    try:
      self._handler.RespondActivityTaskCanceled(args.canceledRequest)
    except shared.ttypes.BadRequestError, badRequestError:
      result.badRequestError = badRequestError
    except shared.ttypes.InternalServiceError, internalServiceError:
      result.internalServiceError = internalServiceError
    except shared.ttypes.EntityNotExistsError, entityNotExistError:
      result.entityNotExistError = entityNotExistError
    oprot.writeMessageBegin("RespondActivityTaskCanceled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class StartWorkflowExecution_args:
  """
  Attributes:
   - startRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'startRequest', (shared.ttypes.StartWorkflowExecutionRequest, shared.ttypes.StartWorkflowExecutionRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, startRequest=None,):
    self.startRequest = startRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.startRequest = shared.ttypes.StartWorkflowExecutionRequest()
          self.startRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartWorkflowExecution_args')
    if self.startRequest is not None:
      oprot.writeFieldBegin('startRequest', TType.STRUCT, 1)
      self.startRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartWorkflowExecution_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - sessionAlreadyExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.StartWorkflowExecutionResponse, shared.ttypes.StartWorkflowExecutionResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sessionAlreadyExistError', (shared.ttypes.WorkflowExecutionAlreadyStartedError, shared.ttypes.WorkflowExecutionAlreadyStartedError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, sessionAlreadyExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.sessionAlreadyExistError = sessionAlreadyExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.StartWorkflowExecutionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sessionAlreadyExistError = shared.ttypes.WorkflowExecutionAlreadyStartedError()
          self.sessionAlreadyExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartWorkflowExecution_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.sessionAlreadyExistError is not None:
      oprot.writeFieldBegin('sessionAlreadyExistError', TType.STRUCT, 3)
      self.sessionAlreadyExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.sessionAlreadyExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetWorkflowExecutionHistory_args:
  """
  Attributes:
   - getRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getRequest', (shared.ttypes.GetWorkflowExecutionHistoryRequest, shared.ttypes.GetWorkflowExecutionHistoryRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, getRequest=None,):
    self.getRequest = getRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getRequest = shared.ttypes.GetWorkflowExecutionHistoryRequest()
          self.getRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetWorkflowExecutionHistory_args')
    if self.getRequest is not None:
      oprot.writeFieldBegin('getRequest', TType.STRUCT, 1)
      self.getRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetWorkflowExecutionHistory_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.GetWorkflowExecutionHistoryResponse, shared.ttypes.GetWorkflowExecutionHistoryResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.GetWorkflowExecutionHistoryResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetWorkflowExecutionHistory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PollForDecisionTask_args:
  """
  Attributes:
   - pollRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pollRequest', (shared.ttypes.PollForDecisionTaskRequest, shared.ttypes.PollForDecisionTaskRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, pollRequest=None,):
    self.pollRequest = pollRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pollRequest = shared.ttypes.PollForDecisionTaskRequest()
          self.pollRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PollForDecisionTask_args')
    if self.pollRequest is not None:
      oprot.writeFieldBegin('pollRequest', TType.STRUCT, 1)
      self.pollRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pollRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PollForDecisionTask_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.PollForDecisionTaskResponse, shared.ttypes.PollForDecisionTaskResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.PollForDecisionTaskResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PollForDecisionTask_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondDecisionTaskCompleted_args:
  """
  Attributes:
   - completeRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'completeRequest', (shared.ttypes.RespondDecisionTaskCompletedRequest, shared.ttypes.RespondDecisionTaskCompletedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, completeRequest=None,):
    self.completeRequest = completeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.completeRequest = shared.ttypes.RespondDecisionTaskCompletedRequest()
          self.completeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondDecisionTaskCompleted_args')
    if self.completeRequest is not None:
      oprot.writeFieldBegin('completeRequest', TType.STRUCT, 1)
      self.completeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.completeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondDecisionTaskCompleted_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
  )

  def __init__(self, badRequestError=None, internalServiceError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondDecisionTaskCompleted_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PollForActivityTask_args:
  """
  Attributes:
   - pollRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pollRequest', (shared.ttypes.PollForActivityTaskRequest, shared.ttypes.PollForActivityTaskRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, pollRequest=None,):
    self.pollRequest = pollRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pollRequest = shared.ttypes.PollForActivityTaskRequest()
          self.pollRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PollForActivityTask_args')
    if self.pollRequest is not None:
      oprot.writeFieldBegin('pollRequest', TType.STRUCT, 1)
      self.pollRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pollRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PollForActivityTask_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.PollForActivityTaskResponse, shared.ttypes.PollForActivityTaskResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.PollForActivityTaskResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PollForActivityTask_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordActivityTaskHeartbeat_args:
  """
  Attributes:
   - heartbeatRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'heartbeatRequest', (shared.ttypes.RecordActivityTaskHeartbeatRequest, shared.ttypes.RecordActivityTaskHeartbeatRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, heartbeatRequest=None,):
    self.heartbeatRequest = heartbeatRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.heartbeatRequest = shared.ttypes.RecordActivityTaskHeartbeatRequest()
          self.heartbeatRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordActivityTaskHeartbeat_args')
    if self.heartbeatRequest is not None:
      oprot.writeFieldBegin('heartbeatRequest', TType.STRUCT, 1)
      self.heartbeatRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.heartbeatRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordActivityTaskHeartbeat_result:
  """
  Attributes:
   - success
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (shared.ttypes.RecordActivityTaskHeartbeatResponse, shared.ttypes.RecordActivityTaskHeartbeatResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.success = success
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = shared.ttypes.RecordActivityTaskHeartbeatResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordActivityTaskHeartbeat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCompleted_args:
  """
  Attributes:
   - completeRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'completeRequest', (shared.ttypes.RespondActivityTaskCompletedRequest, shared.ttypes.RespondActivityTaskCompletedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, completeRequest=None,):
    self.completeRequest = completeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.completeRequest = shared.ttypes.RespondActivityTaskCompletedRequest()
          self.completeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCompleted_args')
    if self.completeRequest is not None:
      oprot.writeFieldBegin('completeRequest', TType.STRUCT, 1)
      self.completeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.completeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCompleted_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCompleted_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskFailed_args:
  """
  Attributes:
   - failRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'failRequest', (shared.ttypes.RespondActivityTaskFailedRequest, shared.ttypes.RespondActivityTaskFailedRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, failRequest=None,):
    self.failRequest = failRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.failRequest = shared.ttypes.RespondActivityTaskFailedRequest()
          self.failRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskFailed_args')
    if self.failRequest is not None:
      oprot.writeFieldBegin('failRequest', TType.STRUCT, 1)
      self.failRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.failRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskFailed_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskFailed_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCanceled_args:
  """
  Attributes:
   - canceledRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'canceledRequest', (shared.ttypes.RespondActivityTaskCanceledRequest, shared.ttypes.RespondActivityTaskCanceledRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, canceledRequest=None,):
    self.canceledRequest = canceledRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.canceledRequest = shared.ttypes.RespondActivityTaskCanceledRequest()
          self.canceledRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCanceled_args')
    if self.canceledRequest is not None:
      oprot.writeFieldBegin('canceledRequest', TType.STRUCT, 1)
      self.canceledRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.canceledRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondActivityTaskCanceled_result:
  """
  Attributes:
   - badRequestError
   - internalServiceError
   - entityNotExistError
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'badRequestError', (shared.ttypes.BadRequestError, shared.ttypes.BadRequestError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'internalServiceError', (shared.ttypes.InternalServiceError, shared.ttypes.InternalServiceError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'entityNotExistError', (shared.ttypes.EntityNotExistsError, shared.ttypes.EntityNotExistsError.thrift_spec), None, ), # 3
  )

  def __init__(self, badRequestError=None, internalServiceError=None, entityNotExistError=None,):
    self.badRequestError = badRequestError
    self.internalServiceError = internalServiceError
    self.entityNotExistError = entityNotExistError

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.badRequestError = shared.ttypes.BadRequestError()
          self.badRequestError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.internalServiceError = shared.ttypes.InternalServiceError()
          self.internalServiceError.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.entityNotExistError = shared.ttypes.EntityNotExistsError()
          self.entityNotExistError.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondActivityTaskCanceled_result')
    if self.badRequestError is not None:
      oprot.writeFieldBegin('badRequestError', TType.STRUCT, 1)
      self.badRequestError.write(oprot)
      oprot.writeFieldEnd()
    if self.internalServiceError is not None:
      oprot.writeFieldBegin('internalServiceError', TType.STRUCT, 2)
      self.internalServiceError.write(oprot)
      oprot.writeFieldEnd()
    if self.entityNotExistError is not None:
      oprot.writeFieldBegin('entityNotExistError', TType.STRUCT, 3)
      self.entityNotExistError.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.badRequestError)
    value = (value * 31) ^ hash(self.internalServiceError)
    value = (value * 31) ^ hash(self.entityNotExistError)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
